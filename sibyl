#!/usr/bin/env bash

# Assign colors if stdout is a terminal supporting colors
if test -t 1; then
  # Exclude from coverage
  # LCOV_EXCL_START
  ncolors=$(tput colors)
  if test -n "$ncolors" && test $ncolors -ge 8; then
    bold="$(tput bold)"
    underline="$(tput smul)"
    standout="$(tput smso)"
    normal="$(tput sgr0)"
    black="$(tput setaf 0)"
    red="$(tput setaf 1)"
    green="$(tput setaf 2)"
    yellow="$(tput setaf 3)"
    blue="$(tput setaf 4)"
    magenta="$(tput setaf 5)"
    cyan="$(tput setaf 6)"
    white="$(tput setaf 7)"
  fi
  # LCOV_EXCL_STOP
fi

function info {
  echo -e "${blue}INFO${normal} $1"
}

function error {
  echo -e "${red}ERROR${normal} $1"
  exit 1
}


# Compile a Dockerfile
function compile {

  # Generate name for image so we can use it later
  name="stencila/$(echo $PWD | sha1sum | awk '{print $1}')"

  info 'Generating image.json'
  cat > image.json << EOL
{
  "platform": {
    "name": "docker",
    "version": "$(docker --version | sed -rn 's/Docker version (.*)/\1/p')"
  },
  "name": "$name"
}
EOL

  # Check if no Dockerfile exists, or if it was previously generated by sibyl
  if [ -f Dockerfile ]; then
    generator=$(sed -rn 's/# Generated by (sibyl)/\1/p' Dockerfile)
  fi
  if [ ! -f Dockerfile ] || [ "$generator" == "sibyl" ]; then
    info "Compiling ${cyan}new${normal} Dockerfile"
  else
    info "Using ${cyan}existing${normal} Dockerfile"
    return
  fi

  # Header used to detect if the folder has a custom Dockerfile or one generatred by sibyl
  # We used to put a time stamp in the header but that makes it harder to test for
  # expected output
  printf "# Generated by sibyl\n\n" > Dockerfile

  # Check if any language requirement files are present
  requires=$(ls -1 | sed -rn 's/(package.json|requirements.txt|r-requires.txt)/\1/p')
  if [ "$requires" == "" ]; then
    info "Starting from ${cyan}alpha${normal} image"
    printf "FROM stencila/alpha\n" >> Dockerfile
  else
    info "Using ${cyan}$requires${normal}"

    info "Starting from ${cyan}alpha-base${normal} image"
    printf "FROM stencila/alpha-base\n" >> Dockerfile

    # Node.js
    if [ -f package.json ]; then
      install_node
    fi

    # Python
    if [ -f requirements.txt ]; then
      install_python
    fi

    # R
    if [ -f r-requires.txt ]; then
      install_r
    fi

    # Create reflection script
    cat > reflect.sh << EOL
cat image.json \\
    <(echo '{"r":' \$(R --slave -e 'stencila:::reflect()' 2> /dev/null || echo "null") '}')  \\
| jq --slurp add
EOL
  
    # Copy it over and execute it
    cat >> Dockerfile << EOL
COPY image.json image.json
COPY reflect.sh reflect.sh
RUN bash reflect.sh > reflection.json
EOL

  fi
}

# Install Node.js and packages
function install_node {
  # Get the node version from package.json e.g.
  #   "engines": {
  #      "node": "7.9.0"
  #   }
  # See https://docs.npmjs.com/files/package.json#engines
  version=$(jq -r '.engines.node' package.json)

  if [ "$version" == "null" ]; then
    # Install latest Nodes
    info "Using ${cyan}latest${normal} Node.js"
    cat >> Dockerfile << EOL
RUN curl -sL "https://deb.nodesource.com/setup_7.x" | bash \\
 && apt-get install -y nodejs
EOL

  else
    # Install specific deb
    # This is currently Nodesource's suggested method for installing a pinned version
    # see https://github.com/nodesource/distributions#faq.
    # Alternatives include NVM and n-install (https://github.com/mklement0/n-install) but
    # they are heavier solutions
    info "Using Node.js ${cyan}$version${normal}"

    major=$(echo $version | sed -rn 's/([0-9]+)\..+/\1/p')

    cat >> Dockerfile << EOL
RUN curl -s "https://deb.nodesource.com/node_$major.x/pool/main/n/nodejs/nodejs_$version-1nodesource1~xenial1_amd64.deb" > node.deb \\
 && dpkg -i node.deb \\
 && rm node.deb
EOL

  fi

  # Parse dependencies in package.json into lines of name@version which can be xarged into
  # a npm global install
  # Trying a npm global install on the package.json fails
  jq -r '.dependencies' package.json | sed -rn 's/  "([^"]+)": "([^"]+)",?/\1@\2/p' > node-requires.txt

  cat >> Dockerfile << EOL
COPY node-requires.txt node-requires.txt
RUN cat node-requires.txt | xargs npm install --global
EOL

}

# Install Python and packages
function install_python {

  # Get the Python version from requirements file e.g.
  #   # python==2.7
  # Note that any patch number in the version will be ignored
  version=$(sed -rn 's/# *(P|p)ython==([0-9](\.[0-9]+)?).*/\2/p' requirements.txt)
  major=$(echo $version | sed -rn 's/([0-9]+).*/\1/p')

  # Install Python and pip
  if [ "$version" == "" ]; then
    info "Installing ${cyan}latest${normal} Python$major"

    cat >> Dockerfile << EOL
RUN apt-get update \\
 && apt-get install -y python$major python$major-dev python$major-pip \\
 && apt-get clean \\
 && rm -rf /var/lib/apt/lists
EOL

  else
  
    info "Installing Python ${cyan}$version${normal}"

    cat >> Dockerfile << EOL
RUN add-apt-repository ppa:fkrull/deadsnakes \\
 && apt-get update \\
 && apt-get install -y python$version python$version-dev python$major-pip \\
 && apt-get clean \\
 && rm -rf /var/lib/apt/lists
EOL

  fi

  # Upgrade pip and install required packages
  cat >> Dockerfile << EOL
COPY requirements.txt requirements.txt
RUN pip$major install --upgrade pip \\
 && pip$major install -r requirements.txt
EOL

}

# Install R and packages
function install_r {

  # Get the R version from requirements file e.g.
  #   # R==3.1.1
  version=$(sed -rn 's/# *(R|r)==([0-9]\.[0-9]+\.[0-9]+)/\2/p' r-requires.txt)

  # Install R
  if [ "$version" != "" ]; then
    suffix="=$version-1xenial0"
    info "Installing R${cyan}$suffix${normal}"
  else
    info "Installing ${cyan}latest${normal} R"
  fi

  cat >> Dockerfile << EOL
RUN add-apt-repository 'deb [arch=amd64,i386] https://cran.rstudio.com/bin/linux/ubuntu xenial/' \\
 && apt-key adv --keyserver keyserver.ubuntu.com --recv-keys E084DAB9 \\
 && apt-get update \\
 && apt-get install -y --no-install-recommends r-base-core$suffix r-base-dev$suffix \\
 && apt-get clean \\
 && rm -rf /var/lib/apt/lists
EOL

  # Create a package installation script
  cat > r-requires.R << EOL
options(repos=structure(c(CRAN='https://cran.rstudio.com')))
install.packages('devtools')
$(sed -rn "s/^([a-zA-Z0-9]+)==(.*)/devtools::install_version('\1', '\2')/p" r-requires.txt)
devtools::install_github('stencila/r')
stencila:::install()
EOL

  # Run package installation script
  printf "COPY r-requires.R r-requires.R\n" >> Dockerfile
  printf "RUN Rscript r-requires.R\n" >> Dockerfile

}

# Get the name of a container image
function name {
  jq -r .name image.json
}

# Build a container image
function build {
  compile

  info 'Building Docker image'
  docker build --tag $(name) .
}

# Reflect a container image
# 
# Gets the `reflection.json` file generated at build time
# from within the container
function reflect {
  docker run $(name) cat reflection.json > reflection.json
}


# Main entry point
# Exclude from coverage
# LCOV_EXCL_START
if [ "$1" == "" ]; then
  echo "${red}USAGE${normal} sibyl <compile|build|make>"
else
  case $1 in
    compile) compile ;;
    name) name ;;
    build) build ;;
    reflect) reflect ;;
    sourced) ;; # Just to allow test files to source this silently
    *)
      error "Unknown task: ${1}"
      ;;
  esac
fi
# LCOV_EXCL_STOP
